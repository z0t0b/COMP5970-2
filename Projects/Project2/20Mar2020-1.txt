	The paper tries to solve the problem of determining what forms of vulnerability mitigation for software written in C or C++ are feasible. The paper attempts to solve this by introducing a model of what attacks are commonly performed on this type of software and then presenting the currently available options for mitigating these attacks (plus the benefits/drawbacks of using each and a reason as to why some of them are not implemented today). The paper presents four different attacks that are common against software written in these programming languages, namely code corruption attacks, control-flow hijack attacks, data-only attacks and information leaks. The paper also presents several policies that are used to combat the previously described attacks, namely memory safety policies, data integrity policies, data space randomization policies, data-flow integrity policies and instruction set randomization / non-executable data policies. The paper provides details as to why some of these policies cannot be implemented such as large overhead (cost of using the policy) and compatibility with source code, binary modules and modularity.
	The paper is strong in the fact that it provides good reasoning behind why they list some of the policies as being infeasible for deployment and give a good detailed overview of every policy as well as a good high-level explanation for how they could help mitigate vulnerabilities within software written in C-based languages. If I had to choose a weakness within the paper it is the lack of real-world examples of how these policies could be implemented â€“ I felt that the explanation of every policy was weak due to there not being many examples of usage of each (e.g., screenshots of the policies in action, more code-based examples of what they protect, etc.). If I had wrote the paper I would have included more screenshots of the attacks being performed and how they are unsuccessful after the policies were put in place, because I feel like this would help the reader understand the overall concepts of how they work and how they could be used in the real world. By creating more real-world examples within the paper, this would successfully extend the concepts of implementing the policies so that readers can potentially use this paper as more of a guide when designing software in these languages.
